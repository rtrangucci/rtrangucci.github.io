<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lecture 12</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script>
window.MathJax = {
  startup: {
    ready() {
      MathJax.startup.defaultReady();
      const {STATE} = MathJax._.core.MathItem;
      MathJax.tex2mml(String.raw`
        \newcommand{\lp}{\left(}
        \newcommand{\rp}{\right)}
        \newcommand{\R}{\mathbb{R}}
        \newcommand{\lb}{\left[}
        \newcommand{\rb}{\right]}
        \newcommand{\ind}[1]{\mathbbm{1}\lp#1\rp}
        \newcommand{\Exp}[1]{\mathbb{E} \lb #1 \rb}
        \newcommand{\ExpA}[2]{\mathbb{E}_{#2} \lb #1 \rb}
        \newcommand{\Prob}[2]{\mathbb{P}_{#2} \lp #1 \rp}
        \newcommand{\indy}{\mathrel{\unicode{x2AEB}}}
        \newcommand{\comp}{^\mathsf{c}}
        \newcommand{\widebar}[1]{\overline{\! #1}}
        \newcommand{\Var}[1]{\mathrm{Var}\lp #1 \rp}
        \newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
        \newcommand{\ddtA}[1]{\frac{\partial^2}{\partial #1^2}}
        \newcommand{\ddtB}[2]{\frac{\partial^2}{\partial #1 \partial #2}}
      `);
    }
  },
  loader: {load: ['[tex]/bbm']},
  tex: {packages: {'[+]': ['bbm']}}
};
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@4.1/tex-mml-chtml.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../papers.html"> 
<span class="menu-text">My papers</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html"> 
<span class="menu-text">Random thoughts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../courses.html"> 
<span class="menu-text">Courses</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lecture 12</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Another thing to note is that if the information matrix is block diagonal, then the gradients corresponding to one parameter block can’t influence the MLE of the opposing parameter block.</p>
<p>For notational ease: <span class="math display">\[\Delta \hat{\boldsymbol{\theta}}_j = \hat{\boldsymbol{\theta}}(\mathbf{1}) - \hat{\boldsymbol{\theta}}(\mathbf{w}_{(j)}).\]</span></p>
<p><span class="citation" data-cites="collett1994modelling">(<a href="#ref-collett1994modelling" role="doc-biblioref">Collett 1994</a>)</span>, citing <span class="citation" data-cites="hall1982outliers">(<a href="#ref-hall1982outliers" role="doc-biblioref">Hall, Rogers, and Pregibon 1982</a>)</span>, suggests standardizing the sensitivity to the control for the inverse of the variance-covariance of the estimated <span class="math inline">\(\hat{\boldsymbol{\theta}}\)</span>, namely: <span class="math display">\[(\Delta \hat{\boldsymbol{\theta}}_j)^T j(\hat{\boldsymbol{\theta}}) (\Delta \hat{\boldsymbol{\theta}}_j).\]</span> Recall that <span class="math display">\[j(\hat{\boldsymbol{\theta}}) = -\ell_{\boldsymbol{\theta}\boldsymbol{\theta}}(\hat{\boldsymbol{\theta}})\]</span> and from the last lecture:</p>
<p><span class="math display">\[
\Delta \hat{\boldsymbol{\theta}}_j \approx \left(-\ell_{\boldsymbol{\theta}\boldsymbol{\theta}}(\hat{\boldsymbol{\theta}})\right)^{-1} \ell_\boldsymbol{\theta}(\hat{\boldsymbol{\theta}};\mathbf{y}_i)
\]</span></p>
<p>This leads to the tidy expression: <span id="eq-tidy"><span class="math display">\[\begin{align}
\ell_\boldsymbol{\theta}(\hat{\boldsymbol{\theta}};\mathbf{y}_i)^T \left(-\ell_{\boldsymbol{\theta}\boldsymbol{\theta}}(\hat{\boldsymbol{\theta}})\right)^{-1} \ell_\boldsymbol{\theta}(\hat{\boldsymbol{\theta}};\mathbf{y}_i).
\end{align} \tag{1}\]</span></span> Alternatively, we can use the sandwich estimator for the asymptotic variance covariance matrix: <span class="math display">\[\begin{align*}
\hat{\Sigma}_{R} &amp; = \left(-\frac{1}{n}\ell_{\boldsymbol{\theta}\boldsymbol{\theta}}(\hat{\boldsymbol{\theta}})\right)^{-1} \left(\frac{1}{n}\sum_{i=1}^n\ell_\boldsymbol{\theta}(\hat{\boldsymbol{\theta}};\mathbf{y}_i)\ell_\boldsymbol{\theta}(\hat{\boldsymbol{\theta}};\mathbf{y}_i)^T\right)\left(-\frac{1}{n}\ell_{\boldsymbol{\theta}\boldsymbol{\theta}}(\hat{\boldsymbol{\theta}})\right)^{-1}
\end{align*}\]</span> Note that this is variance/covariance matrix for <span class="math inline">\(\sqrt{n}(\hat{\theta}_n - \theta^\dagger)\)</span>. We instead want to get a sense for the variance/covariance matrix for <span class="math inline">\(\hat{\theta}_n\)</span>, so we divide the expression by <span class="math inline">\(\sqrt{n}\)</span>, leading to a variance estimate that is scaled by <span class="math inline">\(n^{-1}\)</span>. Using the statistic <span class="math display">\[(\Delta \hat{\boldsymbol{\theta}}_j)^T (n^{-1}\hat{\Sigma}_{R})^{-1} (\Delta \hat{\boldsymbol{\theta}}_j)\]</span> and noting the following equality: <span class="math display">\[\begin{align*}
(n^{-1} \hat{\Sigma}_{R})^{-1} &amp; = -\ell_{\boldsymbol{\theta}\boldsymbol{\theta}}(\hat{\boldsymbol{\theta}}) \left(\sum_{i=1}^n\ell_\boldsymbol{\theta}(\hat{\boldsymbol{\theta}};\mathbf{y}_i)\ell_\boldsymbol{\theta}(\hat{\boldsymbol{\theta}};\mathbf{y}_i)^T\right)^{-1}\left(-\ell_{\boldsymbol{\theta}\boldsymbol{\theta}}(\hat{\boldsymbol{\theta}})\right)
\end{align*}\]</span> yields: <span class="math display">\[\ell_\boldsymbol{\theta}(\hat{\boldsymbol{\theta}};\mathbf{y}_i)^T\left(\sum_{i=1}^n\ell_\boldsymbol{\theta}(\hat{\boldsymbol{\theta}};\mathbf{y}_i)\ell_\boldsymbol{\theta}(\hat{\boldsymbol{\theta}};\mathbf{y}_i)^T\right)^{-1}\ell_\boldsymbol{\theta}(\hat{\boldsymbol{\theta}};\mathbf{y}_i).\]</span> Let’s do an example where we can analytically calculate the influence score for a single observation on the parameter vector:</p>
<div class="exmp">
<p><strong>Example 1</strong>. Influence of datapoints in exponential regression model The inverse of the observed information is: <span class="math display">\[\begin{align}
\hat{\mathcal{I}}^{-1}(\hat{\lambda}, \hat{\beta}) =  \frac{1}{\frac{(r_1 + r_2)e^{\hat{\beta}} T_2}{\hat{\lambda}} - e^{2 \hat{\beta}} T_2^2}\begin{bmatrix}
      \hat{\lambda} e^{\hat{\beta}} T_2  &amp; -e^{\hat{\beta}} T_2 \\
        -e^{\hat{\beta}} T_2 &amp; \frac{r_1 + r_2}{\hat{\lambda}^2}
    \end{bmatrix}
\end{align}\]</span> which simplifies to: <span class="math display">\[\begin{align}
    \begin{bmatrix}
        \frac{r_1}{T_1^2} &amp; -\frac{1}{T_1}\\
        -\frac{1}{T_1} &amp; \frac{r_1 + r_2}{r_1 r_2}
    \end{bmatrix}
\end{align}\]</span> and the score equations are: <span class="math display">\[\begin{align}
\frac{\partial}{\partial \lambda} \ell(\lambda, \beta) &amp; = \frac{\delta_i}{\lambda} - e^{z_i \beta} t_i\\
\frac{\partial}{\partial \beta} \ell(\lambda, \beta) &amp; = \delta_i z_i  - z_i \lambda e^{z_i \beta} t_i
\end{align}\]</span> which we evaluate at the MLE: <span class="math display">\[\begin{align*}
\hat{\lambda} &amp; = \frac{r_1}{T_1} \\
\hat{e^\beta} &amp; = \frac{r_2}{T_2}\frac{T_1}{r_1}
\end{align*}\]</span> to yield <span class="math display">\[\begin{align}
\frac{\partial}{\partial \lambda} \ell(\lambda, \beta) &amp; = \frac{\delta_i T_1 }{r_1} - \left(\frac{r_2}{T_2}\frac{T_1}{r_1}\right)^{z_i} t_i\\
\frac{\partial}{\partial \beta} \ell(\lambda, \beta) &amp; = \delta_i z_i  -\left(\frac{r_2}{T_2}\right)z_i t_i
\end{align}\]</span></p>
<p>For an individual with <span class="math inline">\(z_i = 0\)</span>, this gives the sensitivities: <span class="math display">\[\begin{align}
\begin{bmatrix}
\frac{\delta_i - t_i \frac{r_1}{T_1}}{T_1}\\
    \frac{t_i}{T_1} - \frac{\delta_i}{r_1}
\end{bmatrix}  =
\begin{bmatrix}
\frac{\delta_i - t_i \frac{r_1}{T_1}}{T_1}\\
    \frac{t_i \frac{r_1}{T_1} - \delta_i}{r_1}
\end{bmatrix}
\end{align}\]</span> These expressions make sense. At a mathematical level, they agree with the total derivatives for each function: <span class="math inline">\(\frac{r_1}{T_1}\)</span> and <span class="math inline">\(-\log(r_1 / T_1)\)</span>. Our expression for the sensitivity of the MLE to the omission of one datapoint is in terms of the difference between the MLE of the full model and the MLE of the leave-one-observation-out model: <span class="math display">\[\hat{\boldsymbol{\theta}}(\mathbf{1}) - \hat{\boldsymbol{\theta}}(\mathbf{w}_{(j)})\]</span> This means that the change in total time at risk for a group <span class="math inline">\(j = 1, 2\)</span>, or <span class="math inline">\(T_j\)</span>, is positive, as is the change in total failures for each group: <span class="math display">\[\begin{align}
T_j - (T_j)_{(i)} &amp; = t_i \\
r_j - (r_j)_{(i)} &amp; = \delta_i
\end{align}\]</span></p>
<p>Then the expression the <span class="math display">\[\begin{align}
    \mathrm{d} \frac{r_1}{T_1} &amp; = \frac{\partial}{\partial r_1} \frac{r_1}{T_1} \mathrm{d}r_1 + \frac{\partial}{\partial T_1} \frac{r_1}{T_1} \mathrm{d}T_1 \\
    &amp; = \frac{\mathrm{d}r_1}{T_1} - \mathrm{d}T_1\frac{r_1}{T_1^2} \\
    &amp; \approx \frac{\delta_i - t_i\frac{r_1}{T_1}}{T_1}
\end{align}\]</span> and <span class="math display">\[\begin{align}
    \mathrm{d} -\log(r_1 / T_1) &amp; = -\frac{\partial}{\partial r_1} \log(r_1 / T_1) \mathrm{d}r_1 - \frac{\partial}{\partial T_1} \log(r_1 / T_1) \mathrm{d}T_1 \\
    &amp; = \frac{\mathrm{d}T_1}{T_1} - \frac{\mathrm{d}r_1}{r_1} \\
    &amp; \approx \frac{t_i\frac{r_1}{T_1}-\delta_i}{r_1}
\end{align}\]</span></p>
<p>It helps to think about the units of the parameter estimates. <span class="math inline">\(\lambda\)</span> measures the rate of failures per unit time, while <span class="math inline">\(\beta\)</span> measures the log of the relative rates of failure. Thus <span class="math inline">\(\beta\)</span> is unitless. Remember that <span class="math display">\[\delta_i - t_i \frac{r_j}{T_j}\]</span> is the residual for an individual <span class="math inline">\(i\)</span> in group <span class="math inline">\(j\)</span>. It compares the observed failure to the expected failure rate, which in the exponential model is just the estimated rate of failure times the time at risk for <span class="math inline">\(i\)</span>, or <span class="math inline">\(t_i\)</span>. When one removes an individual from group 1 the estimate for the rate of failure in group 1 declines by the residual expected failure per unit time. At the same time, the log relative rate of failure must increase by the residual failure per unit failure because the estimator for <span class="math inline">\(\beta\)</span> is <span class="math inline">\(\log(r_2 / T_2) - \log(\hat{\lambda})\)</span>. Thus any change in <span class="math inline">\(\hat{\lambda}\)</span> has an opposite change for <span class="math inline">\(\hat{\beta}\)</span>.</p>
<p>For an individual with <span class="math inline">\(z_i = 1\)</span>, the sensitivities are: <span class="math display">\[\begin{align}
\begin{bmatrix}
0\\
  \frac{\delta_i}{r_2} -  \frac{t_i}{T_2}
\end{bmatrix} =
\begin{bmatrix}
0\\
    \frac{\delta_i - t_i \frac{r_2}{T_2}}{r_2}
\end{bmatrix}
\end{align}\]</span> Again, this makes sense; <span class="math inline">\(\hat{\lambda} = \frac{r_1}{T_1}\)</span>, so omitting an individual in group <span class="math inline">\(2\)</span> can’t change the MLE for <span class="math inline">\(\lambda\)</span>. Finally, given <span class="math inline">\(\hat{\beta} = \log(r_2 / T_2) - \log(\hat{\lambda})\)</span>, omitting a datapoint will decrease the failure rate estimate within group <span class="math inline">\(2\)</span> by the residual scaled by the failure rate. Note the total derivative of <span class="math inline">\(\log(r_2 / T_2)\)</span>, as above, is: <span class="math display">\[\begin{align}
    \mathrm{d} \log(r_2 / T_2) &amp; = \frac{\mathrm{d}r_2}{r_2} - \frac{\mathrm{d}T_2}{T_2}
\end{align}\]</span></p>
<p>We can also calculate the scaled total deviation. For <span class="math inline">\(z_i = 0\)</span> we have: <span class="math display">\[\begin{align}
   \frac{\left(t_i \frac{r_1}{T_1} - \delta_i\right)^2}{r_1}
\end{align}\]</span> and for <span class="math inline">\(z_i = 1\)</span> we have <span class="math display">\[\begin{align}
   \frac{\left(t_i \frac{r_2}{T_2} - \delta_i\right)^2}{r_2}
\end{align}\]</span></p>
</div>




<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-collett1994modelling" class="csl-entry" role="listitem">
Collett, David. 1994. <em>Modelling Survival Data in Medical Research</em>. Chapman &amp; Hall.
</div>
<div id="ref-hall1982outliers" class="csl-entry" role="listitem">
Hall, Gaineford J, William H Rogers, and Daryl Pregibon. 1982. <em>Outliers Matter in Survival Analysis</em>. Vol. 6761. Rand Corporation.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>