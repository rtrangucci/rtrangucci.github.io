<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Missing data lecture 9: MAR vs.&nbsp;MAAR (again) and Data Coarsening</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-fd68462179fdb1eb8400a3e2e38edf1e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script>
window.MathJax = {
  startup: {
    ready() {
      MathJax.startup.defaultReady();
      const {STATE} = MathJax._.core.MathItem;
      MathJax.tex2mml(String.raw`
      \newcommand{\R}{\mathbb{R}}
      \newcommand{\comp}{\mathsf{c}}
        \newcommand{\lp}{\left(}
        \newcommand{\rp}{\right)}
        \newcommand{\lb}{\left[}
        \newcommand{\rb}{\right]}
        \newcommand{\ind}[1]{\mathbbm{1}\lp#1\rp}
        \newcommand{\Exp}[1]{\mathbb{E} \lb #1 \rb}
        \newcommand{\ExpA}[2]{\mathbb{E}_{#2} \lb #1 \rb}
        \newcommand{\Var}[1]{\text{Var} \lp #1 \rp}
        \newcommand{\VarA}[2]{\text{Var}_{#2} \lp #1 \rp}
        \newcommand{\indy}{\mathrel{\unicode{x2AEB}}}
        \newcommand{\Prob}[2]{\mathbb{P}_{#2} \lp #1 \rp}
        \newcommand{\abs}[1]{\left| #1 \right|}
        \newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
      `);
    }
  },
  loader: {load: ['[tex]/bbm']},
  tex: {packages: {'[+]': ['bbm']}}
};
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@4.1/tex-mml-chtml.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../papers.html"> 
<span class="menu-text">My papers</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Random thoughts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../courses.html"> 
<span class="menu-text">Courses</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#clarifying-mar-vs.-maar" id="toc-clarifying-mar-vs.-maar" class="nav-link active" data-scroll-target="#clarifying-mar-vs.-maar">Clarifying MAR vs.&nbsp;MAAR</a></li>
  <li><a href="#unit-missingness" id="toc-unit-missingness" class="nav-link" data-scroll-target="#unit-missingness">Unit missingness</a></li>
  <li><a href="#coarsened-data" id="toc-coarsened-data" class="nav-link" data-scroll-target="#coarsened-data">Coarsened data</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Missing data lecture 9: MAR vs.&nbsp;MAAR (again) and Data Coarsening</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="clarifying-mar-vs.-maar" class="level2">
<h2 class="anchored" data-anchor-id="clarifying-mar-vs.-maar">Clarifying MAR vs.&nbsp;MAAR</h2>
<p>Let there be <span class="math inline">\(n\)</span> units, of which we’re interested in measuring <span class="math inline">\(K\)</span> variables. Let the <span class="math inline">\(n \times K\)</span> matrix of observations be denoted <span class="math inline">\(Y\)</span>, with elements <span class="math inline">\(y_{ij}\)</span> while a realization of this matrix is called <span class="math inline">\(\tilde{y}\)</span>, with elements <span class="math inline">\(\tilde{y}_{ij}\)</span>. Let the matrix of missingness indicators be denoted <span class="math inline">\(M\)</span>, elements <span class="math inline">\(m_{ij}\)</span>, with a particular realization <span class="math inline">\(\tilde{m}\)</span>, with elements <span class="math inline">\(\tilde{m}_{ij}\)</span>. Let <span class="math inline">\(Y_{(0)} = \{y_{ij} \mid m_{ij} = 0, i = 1, \dots, n, j = 1, \dots, K \}\)</span>. Let <span class="math inline">\(Y_{(1)} = \{y_{ij} \mid m_{ij} = 1, i = 1, \dots, n, j = 1, \dots, K \}\)</span>. Let <span class="math inline">\(\mathcal{Y}_{(1)}\)</span> be the sample space of the missing values. Let a realization of these sets of variables be <span class="math inline">\(\tilde{y}_{(0)}\)</span> and <span class="math inline">\(\tilde{y}_{(1)}\)</span>.</p>
<p>The joint likelihood of the observed data and the missingness indicators is:</p>
<p><span class="math display">\[
L_\text{full}(\theta, \phi \mid \tilde{y}_{(0)}, \tilde{m}) = \int_{\mathcal{Y}_{(1)}} f_Y(\tilde{y}_{(0)}, y_{(1)} \mid \theta) P(M = \tilde{m} \mid Y_{(0)} = \tilde{y}_{(0)}, Y_{(1)} = y_{(1)}, \phi) dy_{(1)}
\]</span></p>
<p>The definition of MAR from the book is as follows:</p>
<div id="def-mar" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 (Missing-at-random)</strong></span> <span class="math display">\[
f_{M \mid Y} (M = \tilde{m} \mid Y_{(0)} = \tilde{y}_{(0)}, Y_{(1)} = y_{(1)}, \phi) = f_{M \mid Y} (M = \tilde{m} \mid Y_{(0)} = \tilde{y}_{(0)}, Y_{(1)} = y_{(1)}^*, \phi)
\]</span> for all <span class="math inline">\(y_{(1)}, y_{(1)}^*, \phi\)</span> .</p>
</div>
<p>The definition of MAAR is:</p>
<div id="def-maar" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 2 (Missing-always-at-random)</strong></span> <span class="math display">\[
f_{M \mid Y} (M = m \mid Y_{(0)} = y_{(0)}, Y_{(1)} = y_{(1)}, \phi) = f_{M \mid Y} (M = m \mid Y_{(0)} = y_{(0)}, Y_{(1)} = y_{(1)}^*, \phi)
\]</span> for all <span class="math inline">\(m, y_{(0)},y_{(1)}, y_{(1)}^*, \phi\)</span>.</p>
</div>
<div id="exm-mar-v-maar" class="theorem example">
<p><span class="theorem-title"><strong>Example 1 (Example MAR vs.&nbsp;MAAR)</strong></span> The example given by <span class="citation" data-cites="littleMissingDataAssumptions2021">Little (<a href="#ref-littleMissingDataAssumptions2021" role="doc-biblioref">2021</a>)</span> is the following:</p>
<p>Suppose we have observations <span class="math inline">\((y_i, x_i)\)</span>, where <span class="math inline">\(y_i\)</span> is potentially missing and <span class="math inline">\(x_i\)</span> is either <span class="math inline">\(1\)</span> or <span class="math inline">\(2\)</span>, denoting group membership. Let <span class="math inline">\(\theta = (\mu_1, \mu_2, \sigma^2)\)</span>, and the model for the observations be <span class="math display">\[
y_i \mid x_i, \theta \sim \text{Normal}(\mu_{x_i}, \sigma^2)
\]</span> The standard confidence interval for the difference in means is: <span class="math display">\[
\bar{y}_2 - \bar{y}_1 \pm t_{\nu, 0.975}(s\sqrt{1/n_1 + 1/n2})
\]</span> This also corresponds to the Bayesian credible interval when using a flat prior on <span class="math inline">\(\mu_1, \mu_2\)</span> and <span class="math inline">\(\log \sigma^2\)</span>. Suppose the missingness mechanism is as follows: <span class="math display">\[
P(m_i = 1 \mid x_i, y_i, \phi) =
\begin{cases}
0 &amp; x_i = 1\\
0 &amp; x_i = 2 \text{ and } y_i \leq \phi\\
1 &amp; x_i = 2 \text{ and } y_i &gt; \phi
\end{cases}
\]</span> That is, for group 2, if the observation is above an unknown cutoff value, the value is not recorded.</p>
<p>Suppose that we have a dataset where there are no missing values. Then the data is MAR but not MAAR, because in repeated hypothetical samples there would be missing values that are MNAR. The Bayesian credible interval is still valid under MAR because we’re conditioning on the dataset we have, whereas the Frequentist interval isn’t valid because it couldn’t be repeated for datasets where <span class="math inline">\(y_i\)</span> is missing for some group <span class="math inline">\(2\)</span> observations.</p>
</div>
</section>
<section id="unit-missingness" class="level2">
<h2 class="anchored" data-anchor-id="unit-missingness">Unit missingness</h2>
<p>When we have an assumption that observations and missingness for units can be considered conditionally independent given parameters <span class="math inline">\(\theta\)</span> and <span class="math inline">\(\phi\)</span>, we get unit MAR instead of MAR.</p>
<p>Let <span class="math inline">\(Y_i\)</span> be the <span class="math inline">\(i^\mathrm{th}\)</span> row of the matrix <span class="math inline">\(Y\)</span>, or the length <span class="math inline">\(K\)</span> random vector representing observations for unit <span class="math inline">\(i\)</span>, while <span class="math inline">\(\tilde{y}_i\)</span> is a particular realization of this random vector and <span class="math inline">\(y_i\)</span> is a dummy vector. Similarly let <span class="math inline">\(M_i\)</span> be the <span class="math inline">\(i^\mathrm{th}\)</span> row of the matrix <span class="math inline">\(M\)</span>, with particular realization <span class="math inline">\(\tilde{m}_i\)</span> and <span class="math inline">\(m_i\)</span> a dummy vector. Furthermore, let <span class="math inline">\(Y_{i(0)}, Y_{i(1)}\)</span> be the observed and missing random vectors of <span class="math inline">\(y_i\)</span>, while <span class="math inline">\(\tilde{y}_{i(0)}, \tilde{y}_{i(1)}\)</span> are realizations of these vectors.</p>
<p>Then the joint distribution of observations and missingness is <span class="math display">\[
f_{Y, M}(y, M = m \mid \theta, \phi) = \prod_{i=1}^n f_{Y_i}(y_i \mid \theta) f_{M_i \mid Y_i}(M_i = m_i \mid Y_i =  y_i, \phi)
\]</span> For unit MAR, the condition becomes:</p>
<div id="def-unit-mar" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3 (Unit missing-at-random)</strong></span> <span class="math display">\[
f_{M_i \mid Y_i}(M_i = \tilde{m}_i \mid Y_{i(0)} = \tilde{y}_{i(0)}, Y_{i(1)} = y_{i(1)}, \phi) =
f_{M_i \mid Y_i}(M_i = \tilde{m}_i \mid Y_{i(0)} = \tilde{y}_{i(0)}, Y_{i(1)} = y_{i(1)}^\star, \phi)
\]</span> for all <span class="math inline">\(y_{i(1)}, y_{i(1)}^\star, \phi\)</span> for all <span class="math inline">\(i\)</span>.</p>
</div>
<p>Note the dependence on all <span class="math inline">\(i\)</span> in <a href="#def-unit-mar" class="quarto-xref">Definition&nbsp;3</a> vs. <a href="#def-mar" class="quarto-xref">Definition&nbsp;1</a>.</p>
</section>
<section id="coarsened-data" class="level2">
<h2 class="anchored" data-anchor-id="coarsened-data">Coarsened data</h2>
<p>Coarsened data is a generalization of missing data that includes other ways in which the resolution of data can be reduced. Examples include censoring, grouping, rounding, or heaping. Heaping is the phenomenon where there are varying levels of resolution reported in the same dataset. For example, on a questionnaire that asks for the the number of cigarettes smoked per day, some people will report exact numbers, and others will report multiples of packs. With rounded data, the coarsening is more deterministic, namely we know that an observation is exactly within the interval, say between <span class="math inline">\([\text{floor}(y), \text{floor}(y)+1]\)</span> With coarsened data, there is still the complete data matrix <span class="math inline">\(y = (y_{ij})\)</span>, but there is now a coarsening variable <span class="math inline">\(c_{ij}\)</span> that interacts with the true value to return the observed data.</p>
<p>Let <span class="math inline">\(w_{ij}\)</span> be the observed data, and let <span class="math inline">\(W(y_{ij}, c_{ij})\)</span> be the function of the true value and the coarsening variable that returns some subset of <span class="math inline">\(\mathcal{Y}_{ij}\)</span> to which <span class="math inline">\(y_{ij}\)</span> belongs. Thus <span class="math inline">\(w_{ij} = W(y_{ij}, c_{ij})\)</span> with the requirement that <span class="math inline">\(y_{ij} \in W(y_{ij}, c_{ij})\)</span>. Let <span class="math inline">\(g_{ij}\)</span> be the observed coarsening random variable that is governed by a function <span class="math inline">\(G(y_{ij}, c_{ij})\)</span> such that <span class="math inline">\(c_{ij} \in G(y_{ij}, c_{ij})\)</span>. Just as <span class="math inline">\(w\)</span> is a coarsened version of <span class="math inline">\(y\)</span>, <span class="math inline">\(g\)</span> is a coarsened version of <span class="math inline">\(c\)</span>.</p>
<p>The simplest nontrivial example is the censored exponential data from above, though we will modify the scenario so that each individual has a potentially different censoring time <span class="math inline">\(c_i\)</span>. Let <span class="math inline">\(y_i\)</span> be the true time to failure, while <span class="math inline">\(c_i\)</span> is the censoring time.</p>
<p><span class="math display">\[
w_{i} = W(y_i, c_i) =
\begin{cases}
y_i &amp; y_i \leq c_i \\
(c_i, \infty) &amp; y_i &gt; c_i
\end{cases}
\]</span> <span class="math display">\[
g_{i} = G(y_i, c_i) =
\begin{cases}
(y_i, \infty) &amp; y_i \leq c_i \\
c_i &amp; y_i &gt; c_i
\end{cases}
\]</span> <!--
Let the vector $c_{(0)} = \{d_i \mid g_i = c_i, i = 1, \dots, n\}$ and let $c_{(1)} = \{c_i \mid g_i \neq c_i, i = 1, \dots, n\}$ 
Let $c = (c_{(0)}, c_{(1)})$ be the vector of coarsening values.
Let $y_{(0)}$ be the set of values that we observe exactly, and $y_{(1)}$ be the set of values that are censored. 
--> Let the realization of <span class="math inline">\(g\)</span> and <span class="math inline">\(w\)</span> be <span class="math inline">\(\tilde{g}\)</span> and <span class="math inline">\(\tilde{w}\)</span>, with elements <span class="math inline">\(\tilde{g}_i\)</span> and <span class="math inline">\(\tilde{w}_i\)</span>. Furthermore, let the distribution of interest for <span class="math inline">\(y_i\)</span> be <span class="math inline">\(f_Y(y_i \mid \theta)\)</span>, while we let the coarsening distributuion be <span class="math inline">\(f_{C \mid Y}(c_i \mid y_i, \phi)\)</span>. Then we can write: <span class="math display">\[
L_{\text{full}}(\theta, \phi \mid \tilde{g}, \tilde{w}) = \int \int f_{C \mid Y}(c \mid y, \phi) f_Y(y \mid \theta) \ind{y \in \tilde{w}} \ind{c \in \tilde{g}}dy\, dc
\]</span></p>
<p>Another way to write this is by simplifying after the integration:</p>
<p>Let the vector <span class="math inline">\(c_{(0)} = \{c_i \mid g_i = c_i, i = 1, \dots, n\}\)</span> and let <span class="math inline">\(c_{(1)} = \{c_i \mid g_i \neq c_i, i = 1, \dots, n\}\)</span> Let <span class="math inline">\(c = (c_{(0)}, c_{(1)})\)</span> be the vector of coarsening values. Let <span class="math inline">\(y_{(0)}\)</span> be the set of values that we observe exactly, and <span class="math inline">\(y_{(1)}\)</span> be the set of values that are censored. Let <span class="math inline">\(\tilde{w}_{(1)}\)</span> be the set of subsets corresponding to the coarsened <span class="math inline">\(y\)</span>’s and the same for <span class="math inline">\(\tilde{g}_{(1)}\)</span>.</p>
<p>Then the integral can be rewritten in terms of these variables:</p>
<p><span class="math display">\[
\small
L_{\text{full}}(\theta, \phi \mid \tilde{c}_{(0)}, \tilde{y}_{(0)}, \tilde{g}_{(1)}, \tilde{w}_{(1)}) = \int \int f_{C \mid Y}(\tilde{c}_{(0)}, c_{(1)} \mid \tilde{y}_{(0)}, y_{(1)},\phi) f_Y(\tilde{y}_{(0)}, y_{(1)} \mid \theta) \ind{y_{(1)} \in \tilde{w}} \ind{c_{(1)} \in \tilde{g}}dy_{(1)}\, dc_{(1)}
\]</span> The likelihood that ignores the coarsening process is:</p>
<p><span class="math display">\[
\small
L_{\text{ign}}(\theta \mid \tilde{y}_{(0)}, \tilde{w}_{(1)}) = \int f_Y(\tilde{y}_{(0)}, y_{(1)} \mid \theta) \ind{y_{(1)} \in \tilde{w}_i} dy_{(1)}
\]</span></p>
<p>This leads to a definition of coarsening at random, or CAR, that relates to conditions on the coarsening distribution:</p>
<p><span class="math display">\[
f_{C \mid Y}(\tilde{c}_{(0)}, c_{(1)} \mid \tilde{y}_{(0)}, y_{(1)}, \phi) = f_{C \mid Y}(\tilde{c}_{(0)}, c_{(1)}^\star \mid \tilde{y}_{(0)}, y_{(1)}^\star, \phi)
\]</span> For all <span class="math inline">\(c_{(1)}, c_{(1)}^\star, y_{(1)}, y_{(1)}^\star, \phi\)</span>.</p>
<p>Each of these definitions has a unit-level variant, as MAR did above:</p>
<p>In the failure time example we have two contributions to the likelihood: <span class="math display">\[
L_{\text{full}}(\theta, \phi \mid y_{(0)}, c_{(0)}) = \prod_{i \mid y_i \leq c_i}  f(y_i \mid \theta) \int_{y_i}^\infty f_{C \mid Y}(c_i \mid y_i, \phi) dc \times \prod_{i \mid y_i &gt; c_i}  \int_{c_i}^\infty f_{C \mid Y}(c_i \mid y, \phi)f(y \mid \theta) dy
\]</span> If we have that <span class="math inline">\(f(c_i \mid y_i, \phi) = f(c_i \mid \phi)\)</span> for all <span class="math inline">\(i\)</span>, and that <span class="math inline">\(\phi\)</span> and <span class="math inline">\(\theta\)</span> are variationally independent, we can write the likelihood as the product of <span class="math inline">\(L_{\text{ign}}(\theta \mid y_{(0)}, c_{(0)})\)</span> and <span class="math inline">\(L_{\text{rest}}(\phi \mid y_{(0)}, c_{(0)})\)</span> <span class="math display">\[
\prod_{i \mid y_i \leq c_i} f(y_i \mid \theta) \prod_{i \mid y_i &gt; c_i} \int_{c_i}^\infty f(y \mid \theta) dy \times \prod_{i \mid y_i \leq c_i} \int_{y_i}^\infty f_{C}(c_i \mid \phi) dc \prod_{i \mid y_i &gt; c_i} f(c_i \mid \phi)
\]</span> In this case, the censoring mechanism is CAR, but not MAR, as we saw earlier.</p>
<p>In the cigarette smoking example, let <span class="math inline">\(y_i\)</span> be the true number of cigarettes smoked per day, and let <span class="math inline">\(c_i\)</span> be an indicator for the precision of reporting. Then define <span class="math inline">\(w_{i}\)</span> to be: <span class="math display">\[
w_{i} =
\begin{cases}
[\text{floor}(y_i), \text{floor}(y_i)+1] &amp; c_i = 0 \\
[20 \times \text{floor}(y_i/20), 20  \times\text{floor}(y_i/20)+20] &amp; c_i = 1
\end{cases}
\]</span> This assumes that people round down the number of cigarettes they smoke, rather than rounding to the nearest integer, like you’d do if there weren’t a stigma around smoking.</p>
<p>Let the lower bound of the interval <span class="math inline">\(w_i\)</span> be <span class="math inline">\(w_{iL}\)</span>, then <span class="math inline">\(g_i\)</span> be defined as: <span class="math display">\[
g_i =
\begin{cases}
c_i &amp; w_{iL} \bmod 20 \neq 0 \\
\{0,1\} &amp; w_{iL} \bmod 20 = 0
\end{cases}
\]</span></p>
<p>Suppose that <span class="math inline">\(f_{C \mid Y}(c_i \mid y_i, \phi) = \Phi(\phi_1 + \phi_2 y_i)^{c_i} (1 - \Phi(\phi_1 + \phi_2 y_i)^{1 - c_i})\)</span>.</p>
<p>Then this example isn’t CAR, because the coarsening is dependent on the number of cigarettes smoked.</p>
<p>What does the likelihood look like?</p>
<p><span class="math display">\[
\small
\begin{aligned}
L(\theta, \phi \mid \tilde{w}, \tilde{g}) &amp; = \prod_{i \mid w_{iL} \bmod 20 \neq 0} \int_{w_{iL}}^{w_{iL} + 1} f_Y(y \mid \theta) (1 - \Phi(\phi_1 + \phi_2 y)) dy \\
&amp; \times \prod_{i \mid w_i \bmod 20 = 0} \int_{w_{iL}}^{w_{iL} + 20} (f_Y(y \mid \theta)\Phi(\phi_1 + \phi_2 y)) dy + \int_{w_{iL}}^{w_{iL} + 1}(f_Y(y \mid \theta)(1 - \Phi(\phi_1 + \phi_2 y)) dy
\end{aligned}
\]</span></p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-littleMissingDataAssumptions2021" class="csl-entry" role="listitem">
Little, Roderick J. 2021. <span>“Missing <span>Data</span> <span>Assumptions</span>.”</span> <em>Annual Review of Statistics and Its Application</em> 8 (1): 89–107. <a href="https://doi.org/10.1146/annurev-statistics-040720-031104">https://doi.org/10.1146/annurev-statistics-040720-031104</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>